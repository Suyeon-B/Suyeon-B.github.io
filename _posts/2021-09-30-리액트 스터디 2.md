---
layout: post
title: React 2) JSX
subheading: 
author: SuyeonBak
categories: React
banner:
  image: /assets/images/post_images/react study/react logo.svg
  opacity: 0.618
  background: "#000"
  height: "100vh"
  min_height: "38vh"
  heading_style: "font-size: 4.25em; font-weight: bold; text-decoration: none"
  subheading_style: "color: #ff5100; font-weight: 400"
tags: [React, Library]
sitemap :
  changefreq : daily
  priority : 1.0

---

💬 본 포스팅은 <리액트를 다루는 기술(개정판) - 김민준 작가님>을 읽고 스터디 목적으로 정리한 글입니다.

> **리액트 스터디 시리즈** 🔗
>
> [1장 - 리액트 시작](https://suyeon-b.github.io/operatingsystem/2021/09/30/%EB%A6%AC%EC%95%A1%ED%8A%B8-%EC%8A%A4%ED%84%B0%EB%94%94-1.html)
>
> [2장 - JSX](https://suyeon-b.github.io/operatingsystem/2021/09/30/%EB%A6%AC%EC%95%A1%ED%8A%B8-%EC%8A%A4%ED%84%B0%EB%94%94-2.html)









## 2장 - JSX

### <u>2.1 코드 이해하기</u>

1장에서 만든 프로젝트를 VS Code로 열고, src/Apps.js 파일을 열어보면 다음과 같은 코드가 있습니다.

```jsx
import logo from'./logo.svg';
import './App.css';


function App() {
	return (
		<div className="App">
			<header className="App-header">        
				<img src={logo} className="App-logo" alt="logo" />        
				<p>          
					Edit <code>src/App.js</code> and save to reload.        
				</p>        
				<a
					className="App-link"
					href="https://reactjs.org"
					target="_blank"
					rel="noopener noreferrer"        
				>          
					Learn React        
				</a>      
			</header>    
		</div>
  );
} 

export default App;
```

- import 구문
  - 특정 파일을 불러오는 기능. 원래 브라우저에는 없던 기능이지만, 브라우저가 아닌 환경에서 자바스크립트를 실행할 수 있게 해주는 환경인 Node.js에서 지원하는 기능입니다.
  - 이러한 기능을 브라우저에서도 사용하기 위해 번들러<sup>[1](#footnote_1)</sup>를 사용합니다.
  - 리액트 프로젝트에서는 번들러로 웹팩을 사용하는 추세입니다. 편의성과 확장성이 다른 도구보다 뛰어나기 때문입니다.

- 웹팩
  - 웹팩을 사용하면 SVG 파일과 CSS 파일도 불러와서 사용할 수 있습니다. 이렇게 파일들을 불러오는 것은 웹팩의 로더(loader)라는 기능이 담당합니다.
  - 로더의 종류도 여러가지입니다. CSS 파일을 불러오는 css-loader같은 것도 있고, 최신 자바스크립트 문법으로 작성된 코드를 ES5<sup>[2](#footnote_2)</sup> 문법으로 변환해주는 babel-loader<sup>[3](#footnote_3)</sup>등도 있습니다.
  - 웹팩의 로더는 원래 직접 설치하고 설정해야 하지만, create-react-app이 모두 대신 해주므로 별도로 설정할 필요가 없습니다.
- `function App() {...}` 부분
  - 이 코드는 App이라는 컴포넌트를 만듭니다.
  - 특히 function 키워드를 사용해서 만들었기 때문에, 함수 컴포넌트입니다.
  - HTML처럼 생겼지만 JSX코드입니다.







### <u>2.2 JSX란?</u>

자바스크립트의 확장 문법입니다. JSX 형식으로 작성된 코드는 브라우저에서 실행되기 전에 코드가 번들링되는 과정에서, 바벨을 사용하여 일반 자바스크립트 형태의 코드로 변환됩니다.

JSX 코드가 아니라면 매번 React.createElement 함수를 사용해야 합니다.







### <u>2.3 JSX의 장점</u>

1. 보기 쉽고 익숙합니다.

2. 활용도가 높습니다.

   : HTML 태그(`div, span..`) 사용 가능, 컴포넌트도 HTML 태그 쓰듯 JSX 안에서 작성 가능 ...







### <u>2.4 JSX 문법</u>

1. 감싸인 요소

   : 컴포넌트에 여러 요소가 있다면 반드시 부모 요소 하나로 감싸야 합니다. Virtual DOM에서 컴포넌트 변화를 감지해 낼 때 효율적으로 비교할 수 있도록 컴포넌트 내부는 하나의 DOM 트리 구조로 이루어져야 한다는 규칙 때문입니다.

   예를 들면 아래 코드는 오류가 발생합니다.

   ```jsx
   // src/App.js
   
   function App() {
     return (
   		<h1>hi react!</h1>
   		<h2>How's it going?</h2>
     )
   }
   
   export default App;
   ```

   따라서 아래 코드처럼 부모요소로 감싸줘야 합니다.

   ```jsx
   // src/App.js
   
   function App() {
     return (
       <div>
       	<h1>hi react!</h1>
   			<h2>How's it going?</h2>
       </div>
     )
   }
   
   export default App;
   ```

   div 태그 대신 Fragment 기능을 사용할 수도 있습니다.

   ```jsx
   // src/App.js
   import { Fragment } from 'react';
   
   function App() {
     return (
       <Fragment>
       	<h1>hi react!</h1>
   			<h2>How's it going?</h2>
       </Fragment>
     )
   }
   
   export default App;
   ```

   그리고 Fragment는 간단하게 아래와 같이 사용할 수도 있습니다.

   ```jsx
   // src/App.js
   import { Fragment } from 'react';
   
   function App() {
     return (
       <>
       	<h1>hi react!</h1>
   			<h2>How's it going?</h2>
       </>
     )
   }
   
   export default App;
   ```

2. 자바스크립트 표현

   : 자바스크립트 표현식을 작성하려면 JSX 내부에서 코드를 { }로 감싸면 됩니다.

   ```jsx
   // src/App.js
   import { Fragment } from 'react';
   
   function App() {
     const name = '리액트';
     return (
       <>
       	<h1>hi {name}!</h1>
   			<h2>How's it going?</h2>
       </>
     )
   }
   
   export default App;
   ```

   - const와 let<sup>[4](#footnote_4)</sup>

3. if문 대신 조건부 연산자

   : if문 사용이 불가능하므로, 필요하다면 JSX 밖에서 if문을 사용하여 사전에 값을 설정하거나, { }안에 조건부 연산자를 사용하면 됩니다. 조건부 연산자는 '삼항 연산자(===)'라고도 합니다.

4. AND 연산자(&&)를 사용한 조건부 렌더링

   : && 연산자로 조건부 렌더링을 할 수 있는 이유는, 리액트에서 false를 렌더링할 때는 null과 마찬가지로 아무것도 나타나지 않기 때문입니다. 따라서 아래와 같은 코드를 보면, falsy한 값인 0은 예외적으로 화면에 나타나므로 주의해야 합니다.

   ```jsx
   const number = 0;
   return number && <div>내용</div>
   ```

5. undefined를 렌더링하지 않기

   : 함수에서 undefined만 반환하여 렌더링 하면 안됩니다. 따라서 OR(||)연산자를 이용하여 오류를 방지하거나, 아래와 같이 JSX 내부에서 undefined를 렌더링하는 것은 괜찮습니다.

   ```jsx
   // src/App.js
   
   import './App.css';
   
   function App() {
     const name = undefined;
     return <div>{name || '리액트'}</div>
   }
   
   export default App;
   ```

6. 인라인 스타일링

   : DOM 요소에 스타일을 적용할 땐 객체 형태로 넣어줍니다. 또한 카멜 표기법을 이용합니다.

7. class 대신 className

   : HTML에서 CSS 클래스를 사용할 땐, <div class = "myclass"></div> 와 같이 쓰는데, JSX에서는 <div className="react">{name}</div> 형태로 쓰고 CSS에서는 .react{...}로 작성합니다.

8. 꼭 닫아야 하는 태그

   : input 태그

   ```jsx
   // src/App.js
   
   import './App.css';
   
   function App() {
     const name = '리액트';
     return (
       <>
       	<div className="react">{name}</div>
       	<input></input> // 혹은 <input />로 self-closing 태그 이용
      	</>
   }
   
   export default App;
   ```

   - self-closing 태그<sup>[5](#footnote_5)</sup>

9. 주석

   - JSX 내부에서 작성할 때

   ```jsx
   {/*...*/}
   // 시작태그를 여러 줄로 작성할 때는 '//...' 형태
   ```

   - JSX 내부가 아닐 때

   ```jsx
   ...
   </div>
   // 이런 주석이나
   /* 이런 주석은 페이지에 뜨게 됩니다.*/
   <input />
   ```







### <u>2.5 ESLint와 Prettier 적용하기</u>

1. ESLint

   : 초록색 줄은 무시 가능, 빨간색 줄은 반드시 고쳐야 함

2. Prettier

   - 자동 indentation 맞춤, 세미콜론(;) 자동 추가, 큰 따옴표로 통일

     : `F1` 누르고 > 'format' 입력 > `Enter`

   -  루트 디렉토리에 `📄.prettierrc` 파일 생성 후 커스터마이징 가능

   - 저장 시 자동 정리 설정

     : `Code > 기본설정 > 설정`에서 'format on save' 검색 후 체크박스 체크 ☑️







---

## 📍 notes

<a name="footnote_1">1.</a><u> 번들러</u>

대표적으로 웹팩, Parcel, browserify 라는 도구들이 있습니다.

번들러 도구를 사용하면 import로 모듈을 불러왔을 때 불러온 모듈을 모두 합쳐 하나의 파일을 생성해 줍니다. 반대로 최적화 과정에서 여러 개의 파일로 분리될 수도 있습니다.



<a name="footnote_2">2.</a><u> ES5</u>

이전 버전의 자바스크립트.



<a name="footnote_3">3.</a><u> babel-loader</u>

최신 자바스크립트 문법으로 작성된 코드를 babel이라는 도구를 사용하여 ES5 문법으로 변환해줍니다. 구버전 웹 브라우저와 호환하기 위해서 꼭 필요한 작업입니다.



<a name="footnote_4">4.</a><u> const & let</u>

- const : 한번 지정하고 나면 변경 불가능한 상수
- let : 동적인 값을 담을 수 있는 변수
- var : 동적인 값을 담을 수 있는 변수. scope가 함수단위
- let과 const는 함수 단위가 아닌 블록 단위이므로, 예를 들어 if 문 내에서 a값을 선언해도, if문 밖의 a 값을 변경하지 않습니다.

ES6 문법에선 var를 사용할 일이 없습니다.

변동 가능한 값에는 let을, 변할 일이 없는 값은 const로 사용하면 됩니다.



<a name="footnote_5">5.</a><u> self-closing 태그</u>

태그 사이에 별도의 내용이 들어가지 않을 때, 태그를 선언하면서 동시에 닫을 수 있는 태그입니다.