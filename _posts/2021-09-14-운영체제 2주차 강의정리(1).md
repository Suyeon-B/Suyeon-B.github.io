---
layout: post
title: 🦖 운영체제 ) 2주차 강의정리 (1)
subheading: 
author: SuyeonBak
categories: OperatingSystem
banner:
  image: /assets/images/post_images/운영체제/표지.png
  opacity: 0.618
  background: "#000"
  height: "100vh"
  min_height: "38vh"
  heading_style: "font-size: 4.25em; font-weight: bold; text-decoration: none"
  subheading_style: "color: #ff5100; font-weight: 400"
tags: [OS, 강의정리]
sitemap :
  changefreq : daily
  priority : 1.0

---

# 🦖 운영체제 강의 정리

**2주차 (1)**

---

## OS History

맨 처음에 컴퓨터가 만들어졌을 땐 배치시스템, 사용자가 실시간으로 시스템에 접근하는 게 아니고, 사용자가 만든 작업물을 제출하면, 컴퓨팅 센터에서 운영자가 일괄로 모아 한번에 처리하는 배치 시스템이었다. 배치시스템은 기본적으로 한 번에 한 개의 작업이 돌아갔음. 그러다보니 컴터시스템에 하드웨어가 전체적으로 활용되지 못하는 문제가 생겼는데, 예를 들면 CPU를 사용하는 동안에 IO 자원은 쉬고있고, 반대의 상황도 발생했다. 따라서 효과적으로 해결하기 위해 multi-programmed 시스템이 만들어짐. 이는 한번에 메모리에 여러 개의 작업을 올려놓고 한 작업을 실행하다가 그 작업에서 입출력을 요청하면 그 작업을 시작함과 동시에 그 작업이 다른 작업으로 CPU가 넘어가는 방식이었음. 그러다보니 CPU와 IO자원이 같이 사용성(utilization)이 높아지는 장점이 생김. 컴퓨터 시스템 관리자 혹은 기관 입장에선 높은 부가가치를 올릴 수 있는 상황이 됨. 그러다 통신 기술이 발전하며 사람들이 기계에 직접 접속할 수 있게 되었는데, 자신의 작업을 실시간으로 제출하고 그 결과를 볼 수 있는 작업을 원하게 됨. (응답성이 낮았다는 말) 따라서 time sharing system이 개발됨. 이는 CPU를 일정한 시간 간격으로 여러 사용자에게 배분하는 그런 시스템임. 이를 멀티 테스킹 시스템이라고도 함. 그러다보니 각 사용자가 작업을 제출하고 기다리는 시간들이 줄어들게 됨. 시스템에 들어온 사람들의 숫자 * time slot만 기다리면 자기 순서가 오도록. 이는 응답성이 좋은 시스템. response time이 짧다. - 여기까지가 현대 운영체제가 갖는 전형, 기본적인 틀이 만들어졌다고 볼 수 있고, 그 뒤로 여러 서버, 임베디드 시스템, IOT, Cloud... 등 조금씩 진화해가고 있다.







![img](/assets/images/post_images/운영체제/2주차/스크린샷 2021-09-14 오전 12.36.44.png)

- CTSS

- OS/360

- MULTICS

  : UNIX의 모체, 사용자가 컴퓨터를 사용할 수 있는 다중사용자 환경을 만들었는데, 이게 OS로 발전하게 됨.

- UNIX

- Linus, Windows, IoS, VxWorks(real time OS), Android(리눅스 위에 올라가있는 모바일 플랫폼이지만 OS에 준하는 취급을 함.)



![img](/assets/images/post_images/운영체제/2주차/스크린샷 2021-09-14 오전 12.46.54.png)

---

## Architectural Supports for OS

: OS를 지원하기 위한 하드웨어 아키텍쳐. 프로세서, 메모리, IO 장치들에서 어떤 지원을 해야하는가

**Topics**

- I/O 시스템과 device driver의 관계
- Interrupt가 뭔가 , trap이 왜 필요하고 어떻게 동작하는가
- 현대 운영체제에서 굉장히 중요한 부분, Protection이란 무엇인가 / System Call, operating mode 가 왜 필요한가
- OS 의 구조
- 부팅 시퀀스









### 1. I/O operations

![img](/assets/images/post_images/운영체제/2주차/스크린샷 2021-09-14 오전 1.17.13.png)

- **I/O devices와 CPU는 concurrent하게 동작할 수 있어야한다.** 즉 병행수행, CPU가 동작하는 중에 I/O도 동작할 수 있어야 하며 그를 통해 utilization을 높여야 한다.

- **I/O 작업은 CPU의 지시에서 시작이 됨.**

  ![img](/assets/images/post_images/운영체제/2주차/스크린샷 2021-09-14 오전 1.13.10.png)

  위 그림에서 디바이스 컨트롤러와 장치 사이에서 데이터를 주고 받는 게 I/O 작업이다. 이 작업은 CPU의 지시에 의해 시작됨.

  CPU는 자기가 I/O하고 싶은 데이터가 있으면, 그 데이터를 메모리에서 읽어서 컨트롤러의 버퍼로(writing to decice), 또는 메모리로 읽어들이고 싶다면 컨트롤러의 버퍼에서 읽어서 메인 메모리로 가져옴(reading from device)

- 컨트롤러는 심플한 프로세서 역할을 함. 이 컨트롤러는 자기가 관리하고 있는 장치들을 책임짐. **대부분은 1 컨트롤러 1디바이스 이지만, 어떤 경우에는 한 컨트롤러가 여러개의 디바이스를 관리하기도 함.**(1 controller multiple device). 대표적으로, SCSI 는 7개의 장치까지 관리 가능. 각각의 디바이스 컨트롤러 안에는 버퍼(작은 용량의 메모리), 레지스터들이 있다. 레지스터는 CPU 안에 있는 빠른 메모리임.

- 모든 디바이스 컨트롤러를 제어하기 위해서 소프트웨어가 만들어져야하는데, 이를 **디바이스 드라이버**라고 함.







### 2. Accesisng I/O Devices

![img](/assets/images/post_images/운영체제/2주차/스크린샷 2021-09-14 오전 1.25.36.png)

- **Memory Mapped I/O**
  - 프로세서에서 장치에 접근할 때, 예를 들어 메모리에 접근할 땐 주소를 가지고 접근한다. 장치에 접근할 때도 마찬가지로 방식이 필요한데, Memory Mapped I/O가 있다. 즉, I/O 장치가 메모리처럼 다뤄지는 것이다. 예를들면, 전체 메모리 어드레스 스페이스가 있는데, 그 어드레스 스페이스 중에서 A 만큼은 메모리가 사용하는 주소고, B만큼은 I/O 장치가 사용하는 주소로 사용한다. 
  - 이렇게 하면, I/O 장치에 접근할 때 메모리에 접근하는 명령어 (loads, stores)를 그대로 써서 접근할 수 있다. 
  - 따라서 메모리 액세스와 I/O 액세스가 일관된 형태를 가지게 되어 편의성이 좋아지고, 그 때문에 일반적으로 사용된다.
- **Special (isolated) I/O**
  - 이 기법은 다른 말로 Channel I/O라고 한다. 
  - 위 Memory Mapped I/O와 달리, CPU가 이 I/O 장치를 위해 메모리 버스 이외에 별도의 버스를 제공해야한다. 이는 별도로 I/O를 다루는 서킷이 필요하니, 하드웨어적으로 코스트가 많이 든다는 의미이기도 하다. 
  - 또 다른 문제는 I/O를 하기 위한 특별한 명령이 프로세스에서 제공되어야 함. ex. inp, outp... 
  - 다만, 메모리 어드레스 스페이스가 아주 작은 스몰 컴퓨터에서는 메모리와 I/O 장치가 주소 공간을 같이 쓰면 비좁다. 이럴 경우 별도의 주소 공간을 사용할 수 있다는 장점이 있다. 그러나 이 또한 별도의 주소 공간을 지원하기 위한 하드웨어가 제공되어야 한다.
  - 또한 특수한 명령어를 쓰기 때문에, 소스코드 개발자 입장에서는 어셈블리의 소스를 보면 쉽게 이해할 수 있다.







### 3. Polling I/O

![img](/assets/images/post_images/운영체제/2주차/스크린샷 2021-09-14 오전 1.55.58.png)

- **Polling I/O**

  - I/O를 할 때, 그 작업을 어떻게 실행하는가에 따라서, 일반적으로 CPU가 I/O 작업에 전체적으로 개입하는 형태를 Polling I/O 또는 Programmed I/O라고 한다. 즉, 모든 I/O operation에 CPU 명령이 사용된다.
  - CPU가 계속해서 현재 I/O 장치의 상태(사용중인지, free 상태인지)를 체크하기 때문에 Polling I/O라고 한다. 소프트웨어가 계속해서 loop을 돌면서 처리한다.
  - 그러나 이 방식은 비효율적이다. 처음에 이 방식이 사용되었는데, 나중에 하드웨어적으로 다른 메커니즘이 제공되면서 대체된다. (뒤에서 자세히 다룰 예정)

- Polling I/O 방식으로 하려면, 각각의 **디바이스 컨트롤러안에는 아래 기능들이 있어야 한다.**

  - **Data-in register (buffer)**

    : host(컨트롤러)가 디바이스에서 들어오는 인풋을 받아주는 레지스터. 예를 들면 키보드, 하드디스크 등의 input 장치에서 어떤 입력이 들어오면 그 입력을 잠시 받아주는 레지스터이다. 작은 디바이스 같은 경우에는 32비트 한 개 정도 레지스터가 필요하지만, 디스크처럼 대용량 장치의 경우엔 64k, 128k와 같이 대용량 버퍼로 제공되기도 한다.

  - **Data-out**

    : Data-in register와 반대로, 장치로 내보낼 데이터가 임시로 머무는 버퍼이다. 시스템에 따라 Data-in Data-out이 구분해서 사용되기도 하지만, 어떤 시스템은 겸용해서 쓰기도 한다.

  - **Status register**

    : 현재 장치의 상태를 표현하는 레지스터. 현재 이 장치가 작업 중인지, 아니면 작업 완료됐는지 등을 표현한다.

  - **Controll regitster**

    : 장치에 보낼 command를 여기다가 쓴다. 예를 들면 read/write 와 같은 명령들을 저장하는 레지스터이다.



![img](/assets/images/post_images/운영체제/2주차/스크린샷 2021-09-14 오전 1.56.09.png)

handshaking<sup>[1](#footnote_1)</sup>

- **device 에 데이터를 write하는 과정** :

  1. Polling 방식으로 CPU에서 I/O작업을 할 때, 데이터를 장치에 쓰려면 일단 CPU가 장치가 현재 작업중인가를 status register의 busy bit(on: 작업중 -  clear 될 때 까지 loop 을 돌며 체크함)를 통해 체크한다. 
  2. 1번 과정에서 available한 상태가 되면 CPU가 command register(또는 control register)에 write bit을 셋한다. 그 다음 CPU가 쓸 데이터를 data-out register에 write한다.
  3. 다음에 CPU가 command-ready bit를 controll register에 셋한다.
  4. 그럼 device controller가 command-ready bit가 셋되는 순간에 status register에 busy bit를 셋한다.
  5. 그 다음 device controller가 command register 안에 어떤 명령어가 들어있는지를 확인하면, 그 안에 write 하라는 명령이 들어있다. 그럼 data-out register의 데이터를 읽어낸다. 그리고 그 데이터를 device로 보낸다.
  6. device controller는 작업이 끝나면 command-ready bit를 clear하고, 에러가 있을 땐 error bit를 클리어하지만, 없다면 error bit도 clear한다. 그리고 busy bit를 clear한다.

  중요한 것은, CPU 입장에서는 계속 status register를 확인해서, 작업 처리를 한다.(polling) - reading 할 때도 마찬가지이다.

  

![img](/assets/images/post_images/운영체제/2주차/스크린샷 2021-09-14 오전 1.56.15.png)

- 문제점
  - 위의 write 하는 과정과 같이, 계속 Device를 체크(polling)하는 데에만 CPU를 활용해서 그 동안에는 다른 작업을 실행할 수 없다는 점이 비효율적이다.
  - 버퍼의 양이 제한되어 있는데, CPU가 잠깐 그 데이터를 가져가지 못하거나 할 땐 금방 buffer에서 넘치는 현상, overflow가 발생할 수 있다. 예를 들면 전화벨이 고장났을 때 수시로 체크하고 제 때에 가서 전화를 받으면 응답을 할텐데, 잠시 늦었다면 그 타이밍을 맞출 수 없다.
- 위 문제점 때문에 마이크로프로세서가 CPU에서 interrupt라는 하트웨어 기능을 제공하기 시작했다. 즉, Polling I/O는 interrupt가 개발되기 전 까지 소프트웨어적으로 하던 방식이며, 너무 비효율적이기에 하드웨어 개발자들이 차라리 프로세스에 기능을 넣어 만들어진 것이 interrupt이다.
- 우측 하단 그림을 보면, device에서 CPU로 인터럽트 신호를 전달할 수 있도록 되어있다. 인터럽트 관련 여러 신호가 있는데, 인터럽트 요청, 인터럽트 인지, 인터럽트 우선순위 전달 등이 있다. 고속 장치들은 인터럽트 Priority가 높고, 키보드 같은 저속 장치들은 상대적으로 낮다. 



### 4. Interrupts

![img](/assets/images/post_images/운영체제/2주차/스크린샷 2021-09-14 오전 1.56.25.png)

- CPU 하드웨어는 Interrupt-request line(우측 하단 그림의 3번)이라는 걸 갖고 있다. 이게 언제 체크되느냐면, 한 machine instruction을 끝내고, 그 다음 machine instruction을 수행하기 직전에 interrupt-request line을 체크한다. `즉, 명령어와 명령어 사이에 인터럽트를 확인한다.` 따라서 명령어 하나가 실행되는 동안에는, 굉장히 짧은 시간이지만 인터럽트가 들어와도 조금은 대기해야한다.

- 예를 들면 다음과 같다. 전화벨을 고쳐 놓고 책을 읽는데, 전화벨이 울렸다. 그럼 북마크를 해두고 전화를 받는다. 전화를 받는 작업이 interrupt handling이다. 이후 전화를 끊고 다시 와서 책을 마저 읽는다. 컴퓨터 시스템에서도 마찬가지이다. 인터럽트가 발생하면, 현재 자기가 작업하던 상황(context)을 저장하고, 전화를 받듯 인터럽트 핸들러로 분기한다. (인터럽트를 처리하는 핸들러가 메모리 어딘가에 지정된 주소로 있을것임.)  인터럽트 루틴을 처리한 뒤엔 다시 멈춘 지점으로 돌아가 작업을 재개한다.

- device controller 입장에선, 인터럽트를 일으키면, CPU가 catch(accept)하고, Interrupt handler가 dispatch(실행)된다. 이후 interrupt 신호를 clear시킨다.

- 대부분의 Operating System은 interrupt-driven 이다.

  - 하드웨어의 여러 장치에서 계속해서 올라오는 interrupt 신호를 그 때 그 때 처리하는 interrupt-driven 소프트웨어이다.
  - 반대로 어플리케이션에서도 소프트웨어 인터럽트의 형태로 요청이 온다. 이를 OS **system call**이라고 하는데, 이 역시 interrupt 형태로 전달한다.

  

![img](/assets/images/post_images/운영체제/2주차/스크린샷 2021-09-14 오전 1.56.35.png)

Interrupt Handling에 대해 위에서 말한 걸 좀 더 디테일하게 보자면 다음과 같다.

인터럽트 핸들링을 할 때, context를 save해야한다고 말했는데, 그 context 중에 중요한 context는 CPU 안의 상태이다. 예를 들면, CPU 안에 레지스터들이 있는데, 그 안의 메모리에 명령어들이 있다. 그런데 여기에 인터럽트가 걸렸을 때, 인터럽트 핸들링을 마치고 원래 작업하던 곳으로 돌아가면 그 값이 사라져버리는 상황이 생길 수 있다. 따라서 CPU 안에 있는 register 값들이 가장 중요한 context임을 알  수 있다. 

- CPU의 상태 보존
  - 일반적으로는 정해진 위치 memmory address에 복제하는 방법이 있다.
  - 키보드, 하드디스크 등의 장치마다 지정된 위치를 다르게 할 수 있다.
  - stack에 저장하는 방법이 있다.
- interrupt handling type
  - polling interrupt / interrupt polling (비효율)
  - 폴링 인터럽트 방식을 개선하여 나온 것이 Vectored interrupt system. 이는 자기의 장치 번호를 실어 인터럽트를 보낼 수가 있으므로, 폴링할 필요가 없다. 따라서 바로 그 장치에 해당되는 인터럽트 핸들러로 바로 분기할 수 있다는 장점이 있다.
  - OS에는 각 장치마다 해야할 일들, Interrupt service routine(= interrupt handler)을 구비하고 있다. 





### 5. Direct Memory Access(DMA)

![img](/assets/images/post_images/운영체제/2주차/스크린샷 2021-09-14 오전 4.15.27.png)

interrupt의 개발로 I/O가 효과적으로 처리되게 되었다. 그러나 다음의 경우를 한 번 생각해보자.

어떤 장치가 굉장히 고속의 장치여서, 계속해서 인터럽트를 걸어온다면 CPU는 너무 잦은 인터럽트를 처리해야한다. 이러한 고속의 장치를 위해서 특별히 고안된 시스템이 있는데, 그걸 Direct Memory Access(DMA) 또는 Direct Memory Access controller라고 한다.

- 어떨 땐 interrupt들도 너무 느리다!
  - device driver가 컨트롤러 레지스터들을 처리해야하고
  - 컨트롤러 레지스터 입장에서는 레지스터 확인하고 I/O 실행하고
  - 다음에 device driver에게 I/O가 완료되었다는 신호를 interrupt를 이용하여 보내야한다. 
  - 이는 큰 데이터를 보낼 때는 오버헤드가 굉장히 큰 결과를 초래한다. 
- 그래서 DMA가 개발되었다!
  - CPU가 개입하지 않고, device controller와 memmory 사이에서 직접 데이터를 전송할 수 있게 만든 기술이다. (이전까지는 인터럽트가 들어오면 CPU가 개입해서 그 인터럽트를 처리하고, 메모리로 보냈었다.)
  - 일반적으로 device controller가 kb, mb 처럼 굉장히 큰 대용량의 데이터를 전달할 때 쓰는 방법이다.
  - 지정된 block의 데이터가 다 완료되면 DMA 컨트롤러가 그제서야 한 번만 인터럽트를 CPU에게 알리는 방법이다.
  - 고속의 I/O 장치에 굉장히 유용한 방법이다.

![img](/assets/images/post_images/운영체제/2주차/스크린샷 2021-09-14 오전 4.15.32.png)

CPU는 DMA 컨트롤러에게 처음에 시작할 Address, 데이터의 크기인 Count, read/write 여부의 Control 명령을 보내고 자신이 하는 일을 계속 한다. 그럼 DMA 컨트롤러가 해당되는 디스크 컨트롤러에게 명령을 보내고(DMA 컨트롤러와 Disk 컨트롤러 간의 handshaking 과정), 디스크 컨트롤러가 직접 메인 메모리로 데이터를 보낸다. 이후 마지막으로 완료가 되면 DMA 컨트롤러가 완료된 사실을 받아서, 전체가 다 처리 되었을 때 한 번만 CPU에게 완료 사실을 알려 처리한다.

![img](/assets/images/post_images/운영체제/2주차/스크린샷 2021-09-14 오전 4.15.37.png)

CPU는 메모리에서 명령어를 가져와서 실행하는 장치이다. CPU와 Memory 사이에 데이터가 오고갈(R/W) 수도 있다. 그리고 CPU에는 cache라는 게 있다. Device에서는 CPU에서 I/O request(read/write)를 처리하고, Device에서는 CPU에 interrupt를 일으킨다. 그리고 Device와 memory 사이에서는 DMA 방식으로 잦은 interrupt 없이 다 완료되었을 때 한 번만 interrupt를 일으킨다.







### 6. Interrupt Timeline

![img](/assets/images/post_images/운영체제/2주차/스크린샷 2021-09-14 오전 4.15.47.png)

위 그림을 보면 CPU는 일반 유저 프로그램을 실행하거나, 인터럽트를 처리하는 두 가지 모드에서 동작한다. 즉, 일반 유저 프로그램을 실행시키다가 인터럽트 처리하다가 다시 일반 유저 프로그램 실행시키다가 ... ∞ 반복한다. 

I/O 장치는 놀고 있다가 I/O request가 오면 받아서 처리를하고, 끝나면 끝났다는 사실을 interrupt를 통해 CPU에게 알린다. 이 과정을 CPU와 I/O 장치가 서로 sink를 맞추어 동작하는 방식이 현대 운영체제 컴퓨터 시스템에서 일어나고 있는 상황이다.





### 7. Modern Interrupt Handling

![img](/assets/images/post_images/운영체제/2주차/스크린샷 2021-09-14 오전 4.15.56.png)

오늘날 인터럽트 핸들링은 기본적으로 대부분의 컴퓨터 시스템이 지원하고 있고, OS에서 활용하고 있는데, 앞서 다뤘던 것 보다는 부가된 기능들을 가지고 있다.

- 현대의 OS는 아래와 같은 보다 정교한 메카니즘이 필요하다.
  - interrupt 지연 기능 (interrupt disable 화 가능)
  - interrupt vector를 이용한 효율적인 인터럽트 핸들러 실행 기능
  - 낮은 priority를 처리하다가도 높은 priority의 인터럽트를 우선적으로 처리하는 기능 (pre-empt processing) 
  - Peripheral Interrupt Controller(PIC)라는 회로가 여러 인터럽트 레벨을 관리하면서 그 중에서 높은 인터럽트가 들어왔을 때 낮은 인터럽트가 딜레이되도록 처리하는 방식
- 일반적으로 CPU는 interrupt request line이 두 종류가 있다.
  - Maskable interrupts : disable 시킬 수 있다. (끌 수 있다.)
  - Non-maskable interrupts : 절대로 끌 수 없다. 예를 들면 메모리 시스템에 에러가 발생하는 등의 크리티컬한 에러라면 Non-maskable 인터럽트로 연결해서 처리하도록 되어있다.
- 인터럽트는 interrupt vector를 가리키는 주소값을 포함한다.
  - interrupt vector (table)는 interrupt 핸들러의 주소값을 담고 있다.
  - 만약에 한 interrupt vector에 여러 interrupt device가 공유할 수 밖에 없는 상황이라면, 일종의 linked list 형식으로 하나하나 찾아서 처리하는 polling과 유사한 방식이 있다.







### 8. Traps and Exceptions

![img](/assets/images/post_images/운영체제/2주차/스크린샷 2021-09-14 오전 4.16.00.png)

- 소프트웨어를 실행시키다보면 인터럽트와 유사한 상황이 아래와 같이 두 가지 조건에서 일어난다.
- 소프트웨어적으로 일으키는 인터럽트
  - Exception: 대부분 비정상적인 상황으로 발생
    - caused by an error (ex. devided by 0, )
    - 어쨌든 trap, exception 모두 동일하게 프로세스 스탑 후 인터럽트 처리하고 다시 돌아와 실행하는 방식으로 동작한다.
  - Trap: 유저 프로그램이 의도적으로 실행시키는 명령. 목적은 대부분 OS 서비스(system calls)을 받기 위해서
    - caused by system calls
    - 소프트웨어 인터럽트 명령어와 같다. (software interrupt라고도 함)
    - trap 명령어를 실행할 때 일종의 인터럽트와 같은 상황이 발생해서 OS (kernel)로 인터럽트가 전달되고, 결국은 CPU로 인터럽트 신호가 들어가서 그 신호에 의해 핸들러가 돌아가게 된다.
- 하드웨어 인터럽트와 거의 동일한 방식으로 처리됨.
  - 프로세스 중단
  - handler를 루틴으로 분기에서 처리하고
  - 다시 돌아와서 아까 처리하던 작업 재개







### 9. Protection

![img](/assets/images/post_images/운영체제/2주차/스크린샷 2021-09-14 오전 4.16.08.png)

현대 운영체제는 각각의 프로세스를 절대적으로 독립적인 개체로 보호하고 있다.

- 어플리케이션 프로그램은
  - 메모리 어디에 잘못 들어가서 계속 그 내용을 바꾸는 경우도 있고,
  - 무한 loop을 돌아서 빠져나오지 못하는 경우도 있다.
- 유저들 중에는
  - 자기 혼자 CPU를 독점하려는 사람도 있고
  - 의도적으로 어떤 프로그램을 심으려는 사람도 있고
  - 자원 등을 너무 많이 확보하려는 사람들도 있다.
- 따라서 OS는 불법적이거나, 또는 실수에 의해 의도치 않게 돌아가는 여러 비정상적인 상황을 보증하기 위해 `A protection mechanism`이라는 걸 제공한다.

![img](/assets/images/post_images/운영체제/2주차/스크린샷 2021-09-14 오전 6.35.25.png)

- 예를 들면 어떤 프로그램이 자기에게 할당된 영역 내에서만 접근할 수 있도록 함
- Base register / Limit register 와 같은 하드웨어 레지스터를 가지고, address가 발생할 때 마다, 그 address가 base와 limit 사이에 들어있는지를 계속 체크한다.
- 나중에는 virtual memory라는 기법이 도입됨.(추후 다룰 예정)

![img](/assets/images/post_images/운영체제/2주차/스크린샷 2021-09-14 오전 6.35.32.png)

또 하나의 Protection 과제는, CPU가 함부로 사용되는 것을 어떻게 막을 것인가다. 

- 협조적인 접근 방식 (Cooperate approach)
  - 각각의 어플리케이션이 다양한 system calls를 이용해 주기적으로 CPU의 컨트롤을 OS에게 넘긴다. 
  - 특별한 system call로 CPU의 컨트롤을 OS에게 넘긴다. (ex. yield())
  - 이 방식은 OS가 다른 유저 어플리케이션들을 신뢔할 때에만 가능하다
- 만약 어떤 프로세스가 의도하지 않았지만 무한 loop에 걸렸다면?
  - 이럴 때  OS가 컨트롤할 수 있는 방법을 고안하다, 하드웨어에서 지원하기 시작한 것이 타이머, 또는 타이머 인터럽트이다.

![img](/assets/images/post_images/운영체제/2주차/스크린샷 2021-09-14 오전 6.35.41.png)

**Timer Hardware**

- 무한 루프를 방지하기 위해 사용된다.
- Non-cooperate approach
  - 정해진 시간(time quantum / time slice)마다 인터럽트를 일으키는 타이머를 셋한다.
  - 인터럽트가 발생하면 인터럽트 핸들러가 동작한다.
  - 1번이 아니라 여러번의 count를 주고 0이 되면 프로그램을 교체할 수도 있다.
  - 타이머가 인터럽트를 일으키면 프로그램이 인터럽트 당하고, OS가 컨트롤을 가져간다.
- OS가 CPU의 컨트롤을 가져올 수 있도록 보장한다.
  - 무한루프 
  - CPU 독점하려고 할 때
  - 위 상황들 같은 경우에도 인터럽트 핸들러는 OS의 코드이므로, 현재 프로세스로 부터 CPU를 뺏고 다른 프로세스로 넘길 수 있는 작업을 처리할 수 있다. 따라서 원천적으로 위 상황들을 막을 수 있다.
- 이 때 타이머 값을 설정하는 것은 protected( or privileged)로, 오직 OS에 의해서만 가능하도록 한다.

![img](/assets/images/post_images/운영체제/2주차/스크린샷 2021-09-14 오전 6.35.47.png)

**Privileged Instructions(특권 명령)**

- 유저 모드에서는 특정 작업이 불가능하도록 설정
- protected instructions라고도 불림. 아래는 OS만 가능한 것들이다.
  - Direct user access - I/O device들이나 디스크, 프린터 등에 직접 접근
  - 메모리 관리하는 instruction들 - TLB 같은 것에 값을 세팅하는 것
  - 특정 레지스터에 접근
  - CPU mode bits를 세팅하는 것 - 유저 모드로 바꿀 수 없도록
  - Halt instruction - 시스템을 멈추는 명령어 사용도 제한
  - timer 세팅 명령어
- 이를 통해 궁극적으로 protection을 지원할 수 있다. 또한 OS/user가 사용하는 영역을 분명히 구분할 수 있기 때문에 user들로 부터 OS를 분리할 수 있다. 

![img](/assets/images/post_images/운영체제/2주차/스크린샷 2021-09-14 오전 6.35.54.png)

![img](/assets/images/post_images/운영체제/2주차/스크린샷 2021-09-14 오전 6.36.00.png)

**CPU 모드들 in Operation**

- user / kernel(OS/supervisor)모드를 통해 보호 가능
- OS는 Kernel mode에서만, user는 user mode에서만 동작한다.
  - OS는 최고 권한을 가지게 되어 모든 자원에 접근할 수 있고, 모든 명령도 가능하다. 어플리케이션들은 자기 바운더리 안에서만 동작하게 된다.
  - privileged instructions는 커널 모드에서만 가능하다.
- CPU는 어떻게 어떤 모드가 실행중인지 알 수 있을까?
  - 하드웨어 안에 모드비트가 있어서 확인할 수 있다.
  - 시스템 콜이 불리면, 커널로 들어가면서 모드비트를 바꾼다. 특히 시스템 콜을 할 때 최종적으로 trap 명령을 실행시키면 모드가 바뀐다.
  - RTI(return from interrupt) - 즉, 인터럽트를 끝내고 돌아올 때도 모드가 바뀐다.
- user 프로그램들은 어떻게 특권명령(privileged instructions)을 사용할 수 있을까?
  - 원칙적으로는 불가능하므로 OS에 요청한다.



![img](/assets/images/post_images/운영체제/2주차/스크린샷 2021-09-14 오전 6.36.05.png)

왜 OS에게 system calls를 요청할 때는 꼭 trap이라는 소프트웨어 인터럽트의 형태를 사용하는가? 함수 호출하듯 사용하게 되면 OS protection이 될 수 없다. 따라서 user process와 kernel은 분리된 객체로 설계할 수 밖에 없었고, 인터럽트의 형태로만 서비스를 요청할 수 있게끔 OS를 설계했다. 

- User는 어떤 privileged operations를 원하면 OS에게 요청한다. (calls system call)
- user mode에서 kernel mode call 하기
  - system calls 사용
  - system calls는 trap 명령어가 사용되어 kernel 모드로 바꿔줌





### 10. System Calls

![img](/assets/images/post_images/운영체제/2주차/스크린샷 2021-09-14 오전 6.36.12.png)

**System Calls**

- OS가 제공하는 서비스, 그리고 그 서비스를 호출하는 프로그래밍 인터페이스 함수들

- 대부분 C / C++로 작성되어있다.

- Wrapper Library

  - open이라는 시스템 콜을 부르려면, 아래 그림과 같이 불러주는 파트가 필요하다. 이를 Wrapper Library라고 함.

    ![img](/assets/images/post_images/운영체제/2주차/스크린샷 2021-09-14 오전 7.42.37.png)

- OS는 system calls를 정의할 때

  - 그 프로그램을 어떻게 call 해야하는지
  - OS는 illegal한 request들, 예를들면 trap을 했는데,
  -  전달된 번호를 봤더니 system calls에 없는 범위면 걷어냄.
  - 각각의 자원마다 적절한 양을 지정함
  - 공평하게 자원이 분배되도록 관리함

- System call은 protected procedure call이다.

  - System call 루틴은 OS code에 존재한다.
  - kernel 모드에서 동작한다
  - 처음엔 user mode에서 불리지만, kernel mode로 들어가서 해당되는 동작을 한다.
  - call이 끝나면 다시 유저모드로 복귀된다.

![img](/assets/images/post_images/운영체제/2주차/스크린샷 2021-09-14 오전 6.36.18.png)

- API를 사용하는 프로그램에서 주로 액세스한다.
- System Call은 OS(window, posix, java 등)마다 다른 종류가 있다.
- 왜 그럼 system call 말고 API를 사용할까?
  - 더 쉽게 사용 가능하다.

---

## 📍 notes

<a name="footnote_1">1.</a> **데이터를 주고 받는 기능**

[시스템](https://terms.naver.com/entry.nhn?docId=853283&ref=y) 내 기능 간의 상호 통신을 위해 정보의 요청 및 전송, [수신 확인](https://terms.naver.com/entry.nhn?docId=848969&ref=y) 등의 신호를 주고받는 기능. 시스템을 위한 [입출력 버스](https://terms.naver.com/entry.nhn?docId=825966&ref=y) 프로토콜은 주고받기에 필요한 것을 규정하고 있다. 특히 각각의 신호가 [입출력](https://terms.naver.com/entry.nhn?docId=825960&ref=y)을 완료했다는 반응이 필요한 [비동기식](https://terms.naver.com/entry.nhn?docId=815502&ref=y) 입출력 시스템에 널리 사용된다.

**[네이버 지식백과]** [주고받기](https://terms.naver.com/entry.naver?docId=1593801) [handshaking] (IT용어사전, 한국정보통신기술협회)

